// @flow

import React from 'react';
import ReactDOM from 'react-dom';
import { browserHistory } from 'react-router';
import { syncHistoryWithStore } from 'react-router-redux';
import asyncBootstrapper from 'react-async-bootstrapper';
import configureApolloClient from 'state/configureApolloClient';
import configureClientStore from 'state/configureClientStore';
import { selectLocationState } from 'state/selectors/route';
import createRoutes from 'routing/createRoutes';
import Root from './root';

/* eslint-disable no-underscore-dangle,no-undef */
const apiUri = global.__API__ || process.env.API;
// The api version is an optional environment variable.
const apiVersion = global.__API_VERSION__ || process.env.API_VERSION;
/* eslint-enable no-underscore-dangle,no-undef */

// Configure the apollo client with persisted queries.
const apolloClient = configureApolloClient(apiUri, apiVersion);

// Create redux store with history. This uses the singleton browserHistory
// provided by react-router. Optionally, this could be changed to leverage a
// created history.
//
// e.g. `const browserHistory = useRouterHistory(createBrowserHistory)();`
const store: AmazeeStore<any, any> = configureClientStore(
  apolloClient,
  browserHistory,
);

const routes: any = createRoutes(store);
const history: any = syncHistoryWithStore(browserHistory, store, {
  selectLocationState,
});

// Find the DOM node generated by the server.
const mountNode = global.document.getElementById('app');

// Encapsulate rendering for hot-reloading.
const render: Function = (Component): void => {
  ReactDOM.render(
    <Component
      store={store}
      routes={routes}
      client={apolloClient}
      history={history}
    />,
    mountNode,
  );
};

if (
  module.hot &&
  module.hot.accept &&
  typeof module.hot.accept === 'function'
) {
  module.hot.accept('./root', (): void => {
    // eslint-disable-next-line global-require
    const ReloadedRoot = require('./root').default;

    asyncBootstrapper(ReloadedRoot).then(() => {
      // Do the initial rendering.
      render(ReloadedRoot);
    });
  });
}

// We run the bootstrapper again, which in this context will ensure that all
// components specified by the rehydrateState will be resolved prior to render.
asyncBootstrapper(Root).then(() => {
  // Do the initial rendering.
  render(Root);
});
